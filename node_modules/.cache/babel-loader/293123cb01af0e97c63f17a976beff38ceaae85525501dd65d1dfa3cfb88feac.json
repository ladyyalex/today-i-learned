{"ast":null,"code":"import _regeneratorRuntime from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  /**\n   * listen to Postgres changes.\n   */\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nvar RealtimeChannel = /*#__PURE__*/function () {\n  function RealtimeChannel( /** Topic name can be any string. */\n  topic) {\n    var _this = this;\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, RealtimeChannel);\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this._rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n      _this.rejoinTimer.reset();\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this.pushBuffer = [];\n    });\n    this._onClose(function () {\n      _this.rejoinTimer.reset();\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this._joinRef()));\n      _this.state = CHANNEL_STATES.closed;\n      _this.socket._remove(_this);\n    });\n    this._onError(function (reason) {\n      if (_this._isLeaving() || _this._isClosed()) {\n        return;\n      }\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n      _this.state = CHANNEL_STATES.errored;\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this._isJoining()) {\n        return;\n      }\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n      _this.state = CHANNEL_STATES.errored;\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, function (payload, ref) {\n      _this._trigger(_this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = this._broadcastEndpointURL();\n  }\n  /** Subscribe registers your client with the server */\n  _createClass(RealtimeChannel, [{\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this2 = this;\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n      var _a, _b;\n      if (!this.socket.isConnected()) {\n        this.socket.connect();\n      }\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        var _this$params$config = this.params.config,\n          broadcast = _this$params$config.broadcast,\n          presence = _this$params$config.presence;\n        this._onError(function (e) {\n          return callback && callback('CHANNEL_ERROR', e);\n        });\n        this._onClose(function () {\n          return callback && callback('CLOSED');\n        });\n        var accessTokenPayload = {};\n        var config = {\n          broadcast: broadcast,\n          presence: presence,\n          postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(function (r) {\n            return r.filter;\n          })) !== null && _b !== void 0 ? _b : []\n        };\n        if (this.socket.accessToken) {\n          accessTokenPayload.access_token = this.socket.accessToken;\n        }\n        this.updateJoinPayload(Object.assign({\n          config: config\n        }, accessTokenPayload));\n        this.joinedOnce = true;\n        this._rejoin(timeout);\n        this.joinPush.receive('ok', function (_ref2) {\n          var serverPostgresFilters = _ref2.postgres_changes;\n          var _a;\n          _this2.socket.accessToken && _this2.socket.setAuth(_this2.socket.accessToken);\n          if (serverPostgresFilters === undefined) {\n            callback && callback('SUBSCRIBED');\n            return;\n          } else {\n            var clientPostgresBindings = _this2.bindings.postgres_changes;\n            var bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n            var newPostgresBindings = [];\n            for (var i = 0; i < bindingsLen; i++) {\n              var clientPostgresBinding = clientPostgresBindings[i];\n              var _clientPostgresBindin = clientPostgresBinding.filter,\n                event = _clientPostgresBindin.event,\n                schema = _clientPostgresBindin.schema,\n                table = _clientPostgresBindin.table,\n                filter = _clientPostgresBindin.filter;\n              var serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                  id: serverPostgresFilter.id\n                }));\n              } else {\n                _this2.unsubscribe();\n                callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n                return;\n              }\n            }\n            _this2.bindings.postgres_changes = newPostgresBindings;\n            callback && callback('SUBSCRIBED');\n            return;\n          }\n        }).receive('error', function (error) {\n          callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n          return;\n        }).receive('timeout', function () {\n          callback && callback('TIMED_OUT');\n          return;\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"presenceState\",\n    value: function presenceState() {\n      return this.presence.state;\n    }\n  }, {\n    key: \"track\",\n    value: function () {\n      var _track = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(payload) {\n        var opts,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              _context.next = 3;\n              return this.send({\n                type: 'presence',\n                event: 'track',\n                payload: payload\n              }, opts.timeout || this.timeout);\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function track(_x) {\n        return _track.apply(this, arguments);\n      }\n      return track;\n    }()\n  }, {\n    key: \"untrack\",\n    value: function () {\n      var _untrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var opts,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n              _context2.next = 3;\n              return this.send({\n                type: 'presence',\n                event: 'untrack'\n              }, opts);\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function untrack() {\n        return _untrack.apply(this, arguments);\n      }\n      return untrack;\n    }()\n  }, {\n    key: \"on\",\n    value: function on(type, filter, callback) {\n      return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(args) {\n        var _this3 = this;\n        var opts,\n          _a,\n          _b,\n          event,\n          endpoint_payload,\n          options,\n          response,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n              if (!(!this._canPush() && args.type === 'broadcast')) {\n                _context3.next = 24;\n                break;\n              }\n              event = args.event, endpoint_payload = args.payload;\n              options = {\n                method: 'POST',\n                headers: {\n                  apikey: (_a = this.socket.accessToken) !== null && _a !== void 0 ? _a : '',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  messages: [{\n                    topic: this.subTopic,\n                    event: event,\n                    payload: endpoint_payload\n                  }]\n                })\n              };\n              _context3.prev = 4;\n              _context3.next = 7;\n              return this._fetchWithTimeout(this.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : this.timeout);\n            case 7:\n              response = _context3.sent;\n              if (!response.ok) {\n                _context3.next = 12;\n                break;\n              }\n              return _context3.abrupt(\"return\", 'ok');\n            case 12:\n              return _context3.abrupt(\"return\", 'error');\n            case 13:\n              _context3.next = 22;\n              break;\n            case 15:\n              _context3.prev = 15;\n              _context3.t0 = _context3[\"catch\"](4);\n              if (!(_context3.t0.name === 'AbortError')) {\n                _context3.next = 21;\n                break;\n              }\n              return _context3.abrupt(\"return\", 'timed out');\n            case 21:\n              return _context3.abrupt(\"return\", 'error');\n            case 22:\n              _context3.next = 25;\n              break;\n            case 24:\n              return _context3.abrupt(\"return\", new Promise(function (resolve) {\n                var _a, _b, _c;\n                var push = _this3._push(args.type, args, opts.timeout || _this3.timeout);\n                if (push.rateLimited) {\n                  resolve('rate limited');\n                }\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = _this3.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                  resolve('ok');\n                }\n                push.receive('ok', function () {\n                  return resolve('ok');\n                });\n                push.receive('timeout', function () {\n                  return resolve('timed out');\n                });\n              }));\n            case 25:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[4, 15]]);\n      }));\n      function send(_x2) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this4 = this;\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this4.socket.log('channel', \"leave \".concat(_this4.topic));\n        _this4._trigger(CHANNEL_EVENTS.close, 'leave', _this4._joinRef());\n      };\n      this.rejoinTimer.reset();\n      // Destroy joinPush to avoid connection timeouts during unscription phase\n      this.joinPush.destroy();\n      return new Promise(function (resolve) {\n        var leavePush = new Push(_this4, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', function () {\n          onClose();\n          resolve('ok');\n        }).receive('timeout', function () {\n          onClose();\n          resolve('timed out');\n        }).receive('error', function () {\n          resolve('error');\n        });\n        leavePush.send();\n        if (!_this4._canPush()) {\n          leavePush.trigger('ok', {});\n        }\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_broadcastEndpointURL\",\n    value: function _broadcastEndpointURL() {\n      var url = this.socket.endPoint;\n      url = url.replace(/^ws/i, 'http');\n      url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n      return url.replace(/\\/+$/, '') + '/api/broadcast';\n    }\n  }, {\n    key: \"_fetchWithTimeout\",\n    value: function () {\n      var _fetchWithTimeout2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url, options, timeout) {\n        var controller, id, response;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              controller = new AbortController();\n              id = setTimeout(function () {\n                return controller.abort();\n              }, timeout);\n              _context4.next = 4;\n              return this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n                signal: controller.signal\n              }));\n            case 4:\n              response = _context4.sent;\n              clearTimeout(id);\n              return _context4.abrupt(\"return\", response);\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _fetchWithTimeout(_x3, _x4, _x5) {\n        return _fetchWithTimeout2.apply(this, arguments);\n      }\n      return _fetchWithTimeout;\n    }() /** @internal */\n  }, {\n    key: \"_push\",\n    value: function _push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this._canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n      return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(_event, payload, _ref) {\n      return payload;\n    }\n    /** @internal */\n  }, {\n    key: \"_isMember\",\n    value: function _isMember(topic) {\n      return this.topic === topic;\n    }\n    /** @internal */\n  }, {\n    key: \"_joinRef\",\n    value: function _joinRef() {\n      return this.joinPush.ref;\n    }\n    /** @internal */\n  }, {\n    key: \"_trigger\",\n    value: function _trigger(type, payload, ref) {\n      var _this5 = this;\n      var _a, _b;\n      var typeLower = type.toLocaleLowerCase();\n      var close = CHANNEL_EVENTS.close,\n        error = CHANNEL_EVENTS.error,\n        leave = CHANNEL_EVENTS.leave,\n        join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n      if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n        return;\n      }\n      var handledPayload = this._onMessage(typeLower, payload, ref);\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n      if (['insert', 'update', 'delete'].includes(typeLower)) {\n        (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(function (bind) {\n          var _a, _b, _c;\n          return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n        }).map(function (bind) {\n          return bind.callback(handledPayload, ref);\n        });\n      } else {\n        (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(function (bind) {\n          var _a, _b, _c, _d, _e, _f;\n          if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n            if ('id' in bind) {\n              var bindId = bind.id;\n              var bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n              return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n            } else {\n              var _bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n              return _bindEvent === '*' || _bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower;\n          }\n        }).map(function (bind) {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            var postgresChanges = handledPayload.data;\n            var schema = postgresChanges.schema,\n              table = postgresChanges.table,\n              commit_timestamp = postgresChanges.commit_timestamp,\n              _type = postgresChanges.type,\n              errors = postgresChanges.errors;\n            var enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: _type,\n              new: {},\n              old: {},\n              errors: errors\n            };\n            handledPayload = Object.assign(Object.assign({}, enrichedPayload), _this5._getPayloadRecords(postgresChanges));\n          }\n          bind.callback(handledPayload, ref);\n        });\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_isClosed\",\n    value: function _isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n  }, {\n    key: \"_isJoined\",\n    value: function _isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n  }, {\n    key: \"_isJoining\",\n    value: function _isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n  }, {\n    key: \"_isLeaving\",\n    value: function _isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n  }, {\n    key: \"_replyEventName\",\n    value: function _replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n    /** @internal */\n  }, {\n    key: \"_on\",\n    value: function _on(type, filter, callback) {\n      var typeLower = type.toLocaleLowerCase();\n      var binding = {\n        type: typeLower,\n        filter: filter,\n        callback: callback\n      };\n      if (this.bindings[typeLower]) {\n        this.bindings[typeLower].push(binding);\n      } else {\n        this.bindings[typeLower] = [binding];\n      }\n      return this;\n    }\n    /** @internal */\n  }, {\n    key: \"_off\",\n    value: function _off(type, filter) {\n      var typeLower = type.toLocaleLowerCase();\n      this.bindings[typeLower] = this.bindings[typeLower].filter(function (bind) {\n        var _a;\n        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n      return this;\n    }\n    /** @internal */\n  }, {\n    key: \"_rejoinUntilConnected\",\n    value: /** @internal */\n    function _rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this._rejoin();\n      }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_onClose\",\n    value: function _onClose(callback) {\n      this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_onError\",\n    value: function _onError(callback) {\n      this._on(CHANNEL_EVENTS.error, {}, function (reason) {\n        return callback(reason);\n      });\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_canPush\",\n    value: function _canPush() {\n      return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n  }, {\n    key: \"_rejoin\",\n    value: function _rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      if (this._isLeaving()) {\n        return;\n      }\n      this.socket._leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n    /** @internal */\n  }, {\n    key: \"_getPayloadRecords\",\n    value: function _getPayloadRecords(payload) {\n      var records = {\n        new: {},\n        old: {}\n      };\n      if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n        records.new = Transformers.convertChangeData(payload.columns, payload.record);\n      }\n      if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n      }\n      return records;\n    }\n  }], [{\n    key: \"isEqual\",\n    value: function isEqual(obj1, obj2) {\n      if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n      }\n      for (var k in obj1) {\n        if (obj1[k] !== obj2[k]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }]);\n  return RealtimeChannel;\n}();\nexport { RealtimeChannel as default };","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","topic","_this","params","arguments","length","undefined","config","socket","_classCallCheck","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","concat","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","_broadcastEndpointURL","_createClass","value","subscribe","callback","_this2","isConnected","connect","_this$params$config","e","accessTokenPayload","postgres_changes","_b","_a","map","r","filter","accessToken","access_token","updateJoinPayload","_rejoin","_ref2","serverPostgresFilters","setAuth","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","_clientPostgresBindin","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","presenceState","_track","_asyncToGenerator","_regeneratorRuntime","mark","_callee","opts","_args","wrap","_callee$","_context","prev","next","type","abrupt","sent","stop","track","_x","apply","_untrack","_callee2","_args2","_callee2$","_context2","untrack","on","_send","_callee3","args","_this3","endpoint_payload","options","response","_args3","_callee3$","_context3","_canPush","method","headers","apikey","body","messages","_fetchWithTimeout","ok","t0","name","Promise","resolve","_push","rateLimited","_c","_x2","updatePayload","_this4","leaving","onClose","close","destroy","leavePush","leave","trigger","url","endPoint","_fetchWithTimeout2","_callee4","controller","_callee4$","_context4","AbortController","setTimeout","abort","fetch","signal","clearTimeout","_x3","_x4","_x5","startTimeout","_onMessage","_event","_ref","_isMember","_this5","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","_e","_d","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record","obj1","obj2","keys","k","default"],"sources":["/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse =\n  | 'ok'\n  | 'timed out'\n  | 'rate limited'\n  | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  /**\n   * listen to Postgres changes.\n   */\n  POSTGRES_CHANGES = 'postgres_changes',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL = this._broadcastEndpointURL()\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence },\n      } = this.params\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\n      this._onClose(() => callback && callback('CLOSED'))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n      }\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive(\n          'ok',\n          ({\n            postgres_changes: serverPostgresFilters,\n          }: {\n            postgres_changes: {\n              id: string\n              event: string\n              schema?: string\n              table?: string\n              filter?: string\n            }[]\n          }) => {\n            this.socket.accessToken &&\n              this.socket.setAuth(this.socket.accessToken)\n\n            if (serverPostgresFilters === undefined) {\n              callback && callback('SUBSCRIBED')\n              return\n            } else {\n              const clientPostgresBindings = this.bindings.postgres_changes\n              const bindingsLen = clientPostgresBindings?.length ?? 0\n              const newPostgresBindings = []\n\n              for (let i = 0; i < bindingsLen; i++) {\n                const clientPostgresBinding = clientPostgresBindings[i]\n                const {\n                  filter: { event, schema, table, filter },\n                } = clientPostgresBinding\n                const serverPostgresFilter =\n                  serverPostgresFilters && serverPostgresFilters[i]\n\n                if (\n                  serverPostgresFilter &&\n                  serverPostgresFilter.event === event &&\n                  serverPostgresFilter.schema === schema &&\n                  serverPostgresFilter.table === table &&\n                  serverPostgresFilter.filter === filter\n                ) {\n                  newPostgresBindings.push({\n                    ...clientPostgresBinding,\n                    id: serverPostgresFilter.id,\n                  })\n                } else {\n                  this.unsubscribe()\n                  callback &&\n                    callback(\n                      'CHANNEL_ERROR',\n                      new Error(\n                        'mismatch between server and client bindings for postgres changes'\n                      )\n                    )\n                  return\n                }\n              }\n\n              this.bindings.postgres_changes = newPostgresBindings\n\n              callback && callback('SUBSCRIBED')\n              return\n            }\n          }\n        )\n        .receive('error', (error: { [key: string]: any }) => {\n          callback &&\n            callback(\n              'CHANNEL_ERROR',\n              new Error(\n                JSON.stringify(Object.values(error).join(', ') || 'error')\n              )\n            )\n          return\n        })\n        .receive('timeout', () => {\n          callback && callback('TIMED_OUT')\n          return\n        })\n    }\n\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const options = {\n        method: 'POST',\n        headers: {\n          apikey: this.socket.accessToken ?? '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            { topic: this.subTopic, event, payload: endpoint_payload },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        if (response.ok) {\n          return 'ok'\n        } else {\n          return 'error'\n        }\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (push.rateLimited) {\n          resolve('rate limited')\n        }\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.rejoinTimer.reset()\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n\n  /** @internal */\n  _broadcastEndpointURL(): string {\n    let url = this.socket.endPoint\n    url = url.replace(/^ws/i, 'http')\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '')\n    return url.replace(/\\/+$/, '') + '/api/broadcast'\n  }\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}