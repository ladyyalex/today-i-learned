{"ast":null,"code":"import _regeneratorRuntime from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nvar noop = function noop() {};\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n    _classCallCheck(this, RealtimeClient);\n    var _a, _b;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    /**\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\n     *\n     * @internal\n     */\n    this._resolveFetch = function (customFetch) {\n      var _fetch;\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        _fetch = function _fetch() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return import('@supabase/node-fetch').then(function (_ref) {\n            var fetch = _ref.default;\n            return fetch.apply(void 0, args);\n          });\n        };\n      } else {\n        _fetch = fetch;\n      }\n      return function () {\n        return _fetch.apply(void 0, arguments);\n      };\n    };\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    var eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    var accessToken = (_b = options === null || options === void 0 ? void 0 : options.params) === null || _b === void 0 ? void 0 : _b.apikey;\n    if (accessToken) this.accessToken = accessToken;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _this.disconnect();\n            _this.connect();\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    })), this.reconnectAfterMs);\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      if (this.conn) {\n        return;\n      }\n      this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n      if (this.conn) {\n        this.conn.binaryType = 'arraybuffer';\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n        this.conn.onmessage = function (event) {\n          return _this2._onConnMessage(event);\n        };\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n        // remove open handles\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.reset();\n      }\n    }\n    /**\n     * Returns all created channels\n     */\n  }, {\n    key: \"getChannels\",\n    value: function getChannels() {\n      return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n  }, {\n    key: \"removeChannel\",\n    value: function () {\n      var _removeChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(channel) {\n        var status;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return channel.unsubscribe();\n            case 2:\n              status = _context2.sent;\n              if (this.channels.length === 0) {\n                this.disconnect();\n              }\n              return _context2.abrupt(\"return\", status);\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function removeChannel(_x) {\n        return _removeChannel.apply(this, arguments);\n      }\n      return removeChannel;\n    }()\n    /**\n     * Unsubscribes and removes all channels\n     */\n  }, {\n    key: \"removeAllChannels\",\n    value: function () {\n      var _removeAllChannels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var values_1;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return Promise.all(this.channels.map(function (channel) {\n                return channel.unsubscribe();\n              }));\n            case 2:\n              values_1 = _context3.sent;\n              this.disconnect();\n              return _context3.abrupt(\"return\", values_1);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function removeAllChannels() {\n        return _removeAllChannels.apply(this, arguments);\n      }\n      return removeAllChannels;\n    }()\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        config: {}\n      };\n      var chan = new RealtimeChannel(\"realtime:\".concat(topic), params, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this3 = this;\n      var topic = data.topic,\n        event = data.event,\n        payload = data.payload,\n        ref = data.ref;\n      var callback = function callback() {\n        _this3.encode(data, function (result) {\n          var _a;\n          (_a = _this3.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n      if (this.isConnected()) {\n        if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n          var isThrottled = this._throttle(callback)();\n          if (isThrottled) {\n            return 'rate limited';\n          }\n        } else {\n          callback();\n        }\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          access_token: token\n        });\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n  }, {\n    key: \"_makeRef\",\n    value: function _makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n      return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_leaveOpenTopic\",\n    value: function _leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c._isJoined() || c._isJoining());\n      });\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_remove\",\n    value: function _remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c._joinRef() !== channel._joinRef();\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_endPointURL\",\n    value: function _endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnMessage\",\n    value: function _onConnMessage(rawMessage) {\n      var _this4 = this;\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref;\n        if (ref && ref === _this4.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this4.pendingHeartbeatRef = null;\n        }\n        _this4.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n        _this4.channels.filter(function (channel) {\n          return channel._isMember(topic);\n        }).forEach(function (channel) {\n          return channel._trigger(event, payload, ref);\n        });\n        _this4.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this5 = this;\n      this.log('transport', \"connected to \".concat(this._endPointURL()));\n      this._flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this5._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n      this._triggerChanError();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n      this._triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel._trigger(CHANNEL_EVENTS.error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n    /** @internal */\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      this.pendingHeartbeatRef = this._makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n    /** @internal */\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(callback) {\n      var _this6 = this;\n      var eventsPerSecondLimitMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n      return function () {\n        if (_this6.inThrottle) return true;\n        callback();\n        if (eventsPerSecondLimitMs > 0) {\n          _this6.inThrottle = true;\n          setTimeout(function () {\n            _this6.inThrottle = false;\n          }, eventsPerSecondLimitMs);\n        }\n        return false;\n      };\n    }\n  }]);\n  return RealtimeClient;\n}();\nexport { RealtimeClient as default };","map":{"version":3,"names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","endPoint","options","_this","_classCallCheck","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","eventsPerSecondLimitMs","inThrottle","_resolveFetch","customFetch","_fetch","fetch","_len","arguments","length","args","Array","_key","then","_ref","default","apply","concat","websocket","Object","assign","eventsPerSecond","_a","Math","floor","_b","apikey","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","disconnect","connect","stop","_createClass","key","value","_this2","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","clearInterval","reset","getChannels","_removeChannel","_callee2","channel","status","_callee2$","_context2","unsubscribe","sent","abrupt","removeChannel","_x","_removeAllChannels","_callee3","values_1","_callee3$","_context3","Promise","all","map","removeAllChannels","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","chan","push","_this3","result","send","includes","isThrottled","_throttle","setAuth","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","vsn","rawMessage","_this4","type","_isMember","_trigger","_this5","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","_this6","setTimeout"],"sources":["/Users/alexandraladyzhensky/Desktop/Udemy/Programming/today-i-learned/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\ntype Fetch = typeof fetch\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  log_level?: 'info' | 'debug' | 'warn' | 'error'\n  fetch?: Fetch\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n  fetch: Fetch\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    const accessToken = options?.params?.apikey\n    if (accessToken) this.accessToken = accessToken\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n\n    this.fetch = this._resolveFetch(options?.fetch)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\n          fetch(...args)\n        )\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimitMs: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n\n      callback()\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true\n\n        setTimeout(() => {\n          this.inThrottle = false\n        }, eventsPerSecondLimitMs)\n      }\n\n      return false\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}